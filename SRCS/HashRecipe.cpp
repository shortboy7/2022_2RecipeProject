#include "../HEADERS/HashRecipe.h"
using namespace std;

HashRecipe::HashRecipe() {
	name = "";
}

void HashRecipe::SetRecipeName(string s)
{
	name = s;
}

void HashRecipe::PlusIngredient(string name, string quantity)
{
	int data = MakeHash(name, name.length()); // ??¸?????´ ???????°??????? ?°???¸?¸?
	int position = data % SIZE_TABLE;		  // ??¨?????? ??°??° -> ?´??¸° ??¸?????¤ ?????¨
	int second_position = 1 + data % 5;
	int count = 1;
	while (Hashtable[position].name != "")
	{
		position = second_position * count;
		count++;
	}
	Hashtable[position].name = name;
	Hashtable[position].quantity = quantity;
	mtrl[ingredientNum].name = name; // ??¸đ ??ˇ?˝??? recipe?? ??ˇ? ???­???? °? ????????
	mtrl[ingredientNum].quantity = quantity;
	ingredientNum++;
}

 int HashRecipe::MakeHash(string t, int tSize) // Rabin-Karp 알고리즘에서 문자열의 해쉬값 구하는 부분 응용
{
	int tHash = 0; // text string??˝??˝ ??˝?˝?°??˝
	int power = 1; // ??˝??˝??˝??˝??˝??˝

	for (int i = 0; i < tSize; i++)
	{
		tHash += t[tSize - 1 - i] * power; // ??˝??˝??˝??˝ ??˝??˝??˝??˝??˝??˝ ??˝??˝??˝????˝??˝??˝ ??˝??˝??˝?´??˝??? (??˝?´??˝ ??˝??˝??˝??˝ * power)??˝??˝ ??˝????˝??˝??˝ ??˝??˝??˝??˝ ??˝??˝??˝????˝ ??˝?˝?°??˝??˝??˝ ??˝??˝??˝??˝?´???.
		if (i < tSize - 1)				   // ??˝??˝??˝??˝??˝??˝ ??˝??˝??˝????˝??˝??˝ ??˝??˝??˝??˝??˝??˝??˝??˝ ??˝??˝??˝??˝ ??˝??˝??˝?´??˝??? 3^0, 3^1, 3^2, ... ??˝??˝ ??˝?´??˝.
			power *= 3;
	}
	if (tHash < 0) // ??˝??˝??˝?°???˝??˝??˝??˝ ??˝?˛??˝??˝??˝ ??˝??˝?ˇ? ??˝??˝??˝??˝
	{
		tHash = tHash * (-1);
	}

	return tHash;
}

int HashRecipe::searchIngredient(string s)
{
	int data = MakeHash(s, s.length());
	int position = data % SIZE_TABLE;
	int second_position = 1 + data % 5;
	int count = 1;
	while (Hashtable[position].name != "")
	{
		if (Hashtable[position].name == s)
		{
			return 1; // ??????
		}
		else
		{
			position = second_position * count;
			count++;
		}
	}
	return 0; // 없음
}


bool HashRecipe::canMakeVec(HashRecipe &myIngred)
{
	for (int i = 0; i < ingredientNum; i++)
	{
		if (myIngred.searchIngredient(mtrl[i].name) == 0)
		{
			return false;
		}
	}
	return true;
}

bool HashRecipe::canMakeHash(HashRecipe &myIngred)
{
	for (int i = 0; i < SIZE_TABLE; i++)
	{
		if (Hashtable[i].name == "")
		{
			continue;
		}
		if (Hashtable[i].name != myIngred.Hashtable[i].name)
		{
			if (myIngred.searchIngredient(Hashtable[i].name) == 0)
			{
				return false;
			}
		}
	}

	return true;
}

void HashRecipe::PrintAll() const
{
	cout << "레시피 이름 : " << name << " 재료 :";
	for (int i = 0; i < SIZE_TABLE; i++)
	{
		if (Hashtable[i].name == "") continue;
		cout << Hashtable[i].name << " ";
	}
	cout << "\n";
}

void	HashRecipe::pushIngredient(std::string & token){
	if (token.empty()) return ;
		int i;
		for (i = token.size() - 1 ; i >= 0 ; i--) {
			if (token[i] == ' ') break;
		}
	std::string aft = token;
	std::string qua = "0";
	if (token.size() > i && i >= 1)
	{
		aft = token.substr(0, i);
		qua = token.substr(i + 1, token.size() - i);
	}
	PlusIngredient(aft, qua);
}