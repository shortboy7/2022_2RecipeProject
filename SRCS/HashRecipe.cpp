#include "../HEADERS/HashRecipe.h"
using namespace std;

HashRecipe::HashRecipe() {
	name = "";
}

void HashRecipe::SetRecipeName(string s)
{
	name = s;
}

void HashRecipe::PlusIngredient(string name, string quantity)
{
	int data = MakeHash(name, name.length()); // ??��?????�� ???????��??????? ?��???��?��?
	int position = data % SIZE_TABLE;		  // ??��?????? ??��??�� -> ?��??���� ??��?????�� ?????��
	int second_position = 1 + data % 5;
	int count = 1;
	while (Hashtable[position].name != "")
	{
		position = second_position * count;
		count++;
	}
	Hashtable[position].name = name;
	Hashtable[position].quantity = quantity;
	mtrl[ingredientNum].name = name; // ??���� ??��?��??? recipe?? ??��? ???��???? ��? ????????
	mtrl[ingredientNum].quantity = quantity;
	ingredientNum++;
}

 int HashRecipe::MakeHash(string t, int tSize) // Rabin-Karp �˰����򿡼� ���ڿ��� �ؽ��� ���ϴ� �κ� ����
{
	int tHash = 0; // text string??��??�� ??��?��?��??��
	int power = 1; // ??��??��??��??��??��??��

	for (int i = 0; i < tSize; i++)
	{
		tHash += t[tSize - 1 - i] * power; // ??��??��??��??�� ??��??��??��??��??��??�� ??��??��??��????��??��??�� ??��??��??��?��??��??? (??��?��??�� ??��??��??��??�� * power)??��??�� ??��????��??��??�� ??��??��??��??�� ??��??��??��????�� ??��?��?��??��??��??�� ??��??��??��??��?��???.
		if (i < tSize - 1)				   // ??��??��??��??��??��??�� ??��??��??��????��??��??�� ??��??��??��??��??��??��??��??�� ??��??��??��??�� ??��??��??��?��??��??? 3^0, 3^1, 3^2, ... ??��??�� ??��?��??��.
			power *= 3;
	}
	if (tHash < 0) // ??��??��??��?��???��??��??��??�� ??��?��??��??��??�� ??��??��?��? ??��??��??��??��
	{
		tHash = tHash * (-1);
	}

	return tHash;
}

int HashRecipe::searchIngredient(string s)
{
	int data = MakeHash(s, s.length());
	int position = data % SIZE_TABLE;
	int second_position = 1 + data % 5;
	int count = 1;
	while (Hashtable[position].name != "")
	{
		if (Hashtable[position].name == s)
		{
			return 1; // ??????
		}
		else
		{
			position = second_position * count;
			count++;
		}
	}
	return 0; // ����
}


bool HashRecipe::canMakeVec(HashRecipe &myIngred)
{
	for (int i = 0; i < ingredientNum; i++)
	{
		if (myIngred.searchIngredient(mtrl[i].name) == 0)
		{
			return false;
		}
	}
	return true;
}

bool HashRecipe::canMakeHash(HashRecipe &myIngred)
{
	for (int i = 0; i < SIZE_TABLE; i++)
	{
		if (Hashtable[i].name == "")
		{
			continue;
		}
		if (Hashtable[i].name != myIngred.Hashtable[i].name)
		{
			if (myIngred.searchIngredient(Hashtable[i].name) == 0)
			{
				return false;
			}
		}
	}

	return true;
}

void HashRecipe::PrintAll() const
{
	cout << "������ �̸� : " << name << "��� :";
	for (int i = 0; i < SIZE_TABLE; i++)
	{
		if (Hashtable[i].name == "") continue;
		cout << Hashtable[i].name << " ";
	}
	cout << "\n";
}

void	HashRecipe::pushIngredient(std::string & token){
	if (token.empty()) return ;
		int i;
		for (i = token.size() - 1 ; i >= 0 ; i--) {
			if (token[i] == ' ') break;
		}
	std::string aft = token;
	std::string qua = "0";
	if (token.size() > i && i >= 1)
	{
		aft = token.substr(0, i);
		qua = token.substr(i + 1, token.size() - i);
	}
	PlusIngredient(aft, qua);
}